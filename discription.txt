Endpoint Detection & Response (EDR) with Attack Graph Correlation and Autonomous SOAR Response

SentinelLite is a production-grade cybersecurity platform designed to provide real-time endpoint threat detection, multi-stage attack correlation, and controlled autonomous incident response for Linux environments. The system integrates Endpoint Detection and Response (EDR), Security Information and Event Management (SIEM), and Security Orchestration, Automation, and Response (SOAR) concepts into a unified architecture focused on high-fidelity detection and operational safety.

At its core, SentinelLite uses an eBPF-based endpoint agent to collect kernel-level telemetry with minimal performance overhead. The agent provides syscall-level visibility including process execution (execve), file access and modification (open, write operations), and network connections (connect). This enables deep behavioral monitoring such as process lineage tracking (parent‚Äìchild relationships), detection of abnormal file write or rename bursts indicative of ransomware activity, and correlation between running processes and active network sockets. The result is high-fidelity telemetry comparable to enterprise EDR solutions.

Instead of generating isolated alerts, SentinelLite constructs an Attack Graph representing attacker activity as a Directed Acyclic Graph (DAG). Security events such as brute-force attempts, successful authentication, privilege escalation, lateral movement, and data exfiltration are automatically correlated into a complete kill chain. This graph-based approach allows the system to identify multi-stage attacks, understand attack progression, and calculate both confidence and blast-radius scores before initiating response actions.

The platform implements a risk-aware autonomous response engine that follows a human-in-the-loop decision model. Response actions are executed based on calculated confidence thresholds:

High confidence threats trigger automated containment actions such as process termination, host isolation, IP blocking, or quarantine.

Medium confidence events generate partial containment with SOC alerts.

Low confidence events are logged and escalated for analyst review only.
This approach balances automation speed with operational safety, preventing false-positive disruption in production environments.

A key differentiator of SentinelLite is its transaction-based response and rollback mechanism. Every automated action is recorded as a reversible transaction, allowing security operators to restore network access, unblock IP addresses, or recover affected services if a response decision needs to be reverted. This introduces reliability and accountability typically absent in academic security projects.

The system also includes a custom rule engine with a detection DSL, enabling security teams to define behavioral rules similar to Sigma-style detections. Analysts can create conditions based on process attributes, command-line arguments, or behavioral sequences, allowing extensible and organization-specific threat detection without modifying core logic.

To demonstrate detection capability and enable realistic evaluation, SentinelLite incorporates a Red Team Simulation Pack consisting of controlled attack scenarios such as SSH brute-force attempts, privilege escalation via sudo misuse, ransomware behavior simulation using safe file encryption patterns, and command-and-control (C2) beaconing simulations. These scenarios allow live demonstrations of attack detection, graph correlation, and automated response workflows.

Additionally, SentinelLite supports multi-host correlation, enabling SOC-level visibility across multiple endpoints. The platform detects anomalous behavior such as the same user authenticating across multiple machines in short intervals, propagation patterns indicating lateral movement, and risk inheritance where compromised hosts influence the risk scoring of connected systems.

Overall, SentinelLite transforms raw endpoint telemetry into contextual attack intelligence by combining kernel-level monitoring, graph-based attack modeling, adaptive rule evaluation, and safe automation. The system represents a complete end-to-end security pipeline and demonstrates how modern EDR and SOC automation platforms operate in enterprise environments.


the first feature to build is :
‚úÖ 1. Process Monitoring (Core Feature)
eBPF should capture:

Process execution (execve)

Process termination

Parent ‚Üí child process relationship

Command line arguments

User who executed the process

‚úÖ Used for:

detecting suspicious commands

process lineage tracking

attack chain building

‚úÖ 2. Process Lineage Tracking
The agent must maintain:

Parent PID (PPID)

Child process chain

Execution tree

Example:

bash ‚Üí curl ‚Üí bash ‚Üí malware
‚úÖ Required for attack graph creation.

‚úÖ 3. File Activity Monitoring
Capture:

File open/write events

File rename operations

Multiple rapid file changes

‚úÖ Used for:

ransomware behaviour detection

suspicious binary drops

unauthorized file modifications

‚úÖ 4. Network Activity Monitoring
Capture:

Outbound connections

Destination IP + port

Process responsible for connection

Connection frequency

‚úÖ Used for:

C2 beaconing detection

data exfiltration patterns

suspicious external connections

‚úÖ 5. Privilege Escalation Detection
Monitor:

sudo executions

setuid/setgid execution

privilege changes

‚úÖ Used for:

escalation stage in kill-chain detection

‚úÖ 6. Authentication Related Events (Basic Level)
Capture:

login attempts (if exposed via hooks/log integration)

failed authentication patterns

sudden privilege use after login

‚úÖ Helps correlate brute force ‚Üí success ‚Üí escalation.

‚úÖ 7. Event Metadata Enrichment
Each event sent to backend must include:

timestamp

hostname / endpoint ID

PID & PPID

username

event type

process name

command line

network/file info (if applicable)

This makes backend correlation possible.

‚úÖ 8. Real-time Event Streaming
eBPF agent should:

send events immediately (not batch logs)

stream events to backend API

avoid disk logging where possible

‚úÖ 9. Performance Safety (Very Important)
eBPF component must:

avoid heavy loops

filter unnecessary events in kernel

send only relevant data to userspace

Goal:
‚úÖ low CPU overhead.

‚úÖ 10. Agent Health & Heartbeat
Agent should periodically send:

alive status

system info

last event timestamp

Backend uses this to detect offline endpoints.

‚úÖ 11. Response Execution Hook (Integration Feature)
Agent should be able to receive commands:

kill process

block IP

isolate host (iptables rule)

quarantine file

This connects eBPF agent to SOAR response engine.


‚úÖ SentinelLite Project ‚Äî Team Setup & Requirements Document
Project Overview
SentinelLite is a Linux-based Endpoint Detection and Response (EDR) system that monitors endpoint activities using eBPF, sends security events to a centralized backend, correlates events into attack chains, and performs automated incident response using SIEM and SOAR concepts.

The project requires a multi-machine setup where multiple endpoints send telemetry to a centralized SOC server.

‚úÖ 1. Operating System Requirement (MANDATORY)
‚úÖ Primary OS for All Team Members
Ubuntu 22.04 LTS (Recommended)

Reason:

Stable kernel support for eBPF

Best compatibility with backend tools

Easy package management

Industry-standard for servers

‚ùå Do NOT use
Kali Linux (only for attack simulation if required)

Windows as endpoint for agent testing

WSL for eBPF testing

WSL can be used only for backend coding, not final testing.

‚úÖ 2. Laptop Role Assignment (6 Members Setup)
Laptop 1 ‚Äî SOC Backend Server
Runs:

Backend API (FastAPI)

Database

Correlation Engine

SOAR Response Engine

Dashboard

Purpose:

Central brain of system

Laptop 2 ‚Äî Primary eBPF Endpoint
Runs:

Ubuntu

eBPF agent development

Event generation

Purpose:

Kernel-level monitoring testing

Laptop 3 ‚Äî Endpoint 2
Runs:

Agent only

Purpose:

Multi-endpoint event testing

Laptop 4 ‚Äî Endpoint 3
Runs:

Agent + response testing

Purpose:

Verify automated response actions

Laptop 5 ‚Äî Endpoint 4
Runs:

Agent + authentication testing

Purpose:

Login failures and privilege escalation testing

Laptop 6 ‚Äî Attack / Simulation Machine
Runs:

Ubuntu or Kali

Purpose:

Controlled attack simulations

‚úÖ 3. Minimum Hardware Requirements
Minimum (Allowed)
CPU: Intel i5 / Ryzen 5

RAM: 8 GB

Storage: 40 GB free

Recommended
CPU: Intel i7 / Ryzen 7

RAM: 16 GB

Storage: 80 GB free

‚úÖ 4. Software Requirements (All Members)
Install on Ubuntu:

Core Tools
git
python3
pip
docker (optional but recommended)
curl
build-essential
Backend Side
Python 3.10+

FastAPI

PostgreSQL or MongoDB

Redis (optional for queue)

Endpoint Side
eBPF tools:

bcc

bpftrace

libbpf

‚úÖ 5. Network Requirements
All laptops connected to same WiFi/LAN

Backend laptop IP fixed (example: 192.168.1.10)

Agents configured with backend IP

System time synchronized on all machines

‚úÖ 6. Development Starting Checklist (Before Coding)
Every member must confirm:

‚úÖ Ubuntu installed and updated
‚úÖ SSH working between machines (optional but helpful)
‚úÖ Backend laptop reachable via IP
‚úÖ Git repository cloned
‚úÖ Python environment working
‚úÖ Ports open for backend (example: 8000)

‚úÖ 7. Development Flow (High Level)
Endpoint agent captures system events using eBPF

Events sent to backend server

Backend stores and correlates events

Attack graph is generated

SOAR engine decides response

Commands sent back to endpoint

Dashboard shows incidents and logs

‚úÖ 8. Important Rules for Team
All development on Ubuntu only

Do not change event format without informing backend team

Test features on one endpoint before multi-machine testing

Keep system clocks synchronized

Never expose backend to public internet during development

‚úÖ 1. Branch Structure (Very Important)
Your repository should have only these main branches:

main        ‚Üí stable, demo-ready code only
develop     ‚Üí integration branch (daily work merges here)
And each member creates their own feature branch:

feature/backend-api
feature/ebpf-agent
feature/database
feature/correlation-engine
feature/response-engine
feature/devsecops
‚úÖ 2. Who Works Where
Branch	Who Uses It	Purpose
main	No direct coding	Final stable version
develop	All members	Integrated testing
feature/*	Individual member	Personal development
‚úÖ 3. Daily Workflow (Follow This Exactly)
Step 1 ‚Äî Start work
git checkout develop
git pull origin develop
git checkout -b feature/your-module
Example:

git checkout -b feature/ebpf-agent
Step 2 ‚Äî Work normally
git add .
git commit -m "Added process monitoring"
Push:

git push origin feature/ebpf-agent
Step 3 ‚Äî Merge to develop (NOT main)
When feature works:

Create Pull Request:

feature/xyz  ‚Üí  develop
One teammate reviews.

Merge into develop.

Step 4 ‚Äî Release to main
Only when:

backend stable

agent working

demo ready

Then:

develop ‚Üí main
‚úÖ 4. Team Rules (Most Important Part)
üö´ Never do this
Never push directly to main

Never code directly on develop

Never edit someone else‚Äôs feature branch

‚úÖ Always do this
Pull latest develop before starting work:

git pull origin develop
Small commits, not huge ones

Clear commit messages

Example:

Added event ingestion API
Fixed correlation bug
Implemented response queue
‚úÖ 5. Recommended Member Mapping
Member	Branch Example
Hrishikesh	feature/backend-api
Aaryaman	feature/ebpf-agent
Parth	feature/database
Jonathan	feature/response-engine
Tanishq	feature/security
Saahithi	feature/devsecops
‚úÖ 6. Why This Works Best for You
Everyone works independently

Integration happens safely in develop

main always stays demo-ready

Easy rollback if something breaks

‚úÖ One-line Team Rule
Code in feature branch ‚Üí merge to develop ‚Üí release to main.
‚úÖ SentinelLite ‚Äî Complete Technology Stack
üß† 1. Endpoint Layer (eBPF Agent)
This runs on all endpoint machines.

Operating System
Ubuntu 22.04 LTS (Recommended)

Core Technologies
eBPF ‚Äî kernel-level event monitoring

BCC / libbpf ‚Äî eBPF program development

bpftrace (debugging & testing)

C / Python (for eBPF + userspace agent)

Monitored Components
Process execution (execve)

File write activity

Network connections

Privilege escalation events

Process lineage tracking

Agent Responsibilities
Capture kernel events

Convert to structured JSON

Stream events to backend

Execute response commands

üåê 2. Backend (SIEM + SOAR Core)
Central brain of the system.

Backend Framework
Python

FastAPI

Core Backend Modules
Event Ingestion API

Correlation Engine

Attack Graph Builder

Incident Manager

Response Dispatcher

Libraries
Pydantic (validation)

Uvicorn (ASGI server)

Requests / HTTPX (agent communication)

üóÑ 3. Database & Storage Layer
Primary Database
PostgreSQL
(Recommended for structured incident data)

Optional
MongoDB (raw event storage)

Redis (queue / caching)

Stored Data
Events

Incidents

Attack graphs

Response logs

Endpoint metadata

‚öôÔ∏è 4. Event Pipeline / Processing
(Optional but recommended for scaling)

Redis Streams OR RabbitMQ

Worker-based event processing

Purpose:

Non-blocking ingestion

Scalable event handling

üß© 5. Detection & Correlation Layer
Algorithms / Logic
Time-window correlation

Attack graph (DAG)

BFS/DFS traversal

Severity scoring

Confidence calculation

Purpose
Convert raw events ‚Üí incidents

Detect multi-stage attacks

ü§ñ 6. SOAR Response Layer
Response Actions
Kill malicious process

Block IP (iptables)

Isolate host

Quarantine file

Alert analyst

Technologies
Linux system commands

Agent command polling API

üìä 7. Dashboard / Visualization
Options (Choose One)
React + FastAPI API (best)
OR

Grafana
OR

Simple Flask dashboard

Features
Incident list

Attack graph visualization

Endpoint status

Response history

üîê 8. Security Layer
API Key authentication (agent ‚Üî backend)

Rate limiting

Input validation

Secure environment variables (.env)

üîÅ 9. DevSecOps & Development Tools
Version Control
Git + GitHub

CI/CD
GitHub Actions

Security Scanning
Semgrep (SAST)

Trivy / pip-audit (dependency scan)

Gitleaks (secret detection)

Containerization (Optional)
Docker

Docker Compose

üñ• 10. Deployment & Testing Environment
Infrastructure
Ubuntu-based laptops or VMs

Same LAN network

Central backend machine

Testing Tools
Kali Linux (attack simulation)

ssh brute force scripts

custom attack simulators